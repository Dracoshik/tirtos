<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>osalintc.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ea9599923402ca8ab47fc3e495999dea.html">arch</a></li><li class="navelem"><a class="el" href="dir_8a12bfbc6daf0ca9a5e29c731dcf645d.html">core</a></li><li class="navelem"><a class="el" href="dir_3121864330c63885920df19b62533aa1.html">a8</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">osalintc.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interrupt APIs implementation for ARM interrupt controller.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;types.h&quot;</code><br />
<code>#include &quot;hw_intc.h&quot;</code><br />
<code>#include &quot;interrupt.h&quot;</code><br />
<code>#include &quot;hw_types.h&quot;</code><br />
<code>#include &quot;soc_am335x.h&quot;</code><br />
<code>#include &quot;cpu.h&quot;</code><br />
<code>#include &quot;console_utils.h&quot;</code><br />
<code>#include &quot;error.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a432332389a8de98ed6abc065a49612ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalintc_8c.html#a432332389a8de98ed6abc065a49612ad">IntDefaultHandler</a> (uint32_t intrId, uint32_t cpuId, void *pUserParam)</td></tr>
<tr class="memdesc:a432332389a8de98ed6abc065a49612ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Default Interrupt Handler. This is the default interrupt handler for all interrupts. The control would reach here if the interrupt is not configured. So to bring to users attention a message will be printed and wait infinitely.  <a href="#a432332389a8de98ed6abc065a49612ad">More...</a><br /></td></tr>
<tr class="separator:a432332389a8de98ed6abc065a49612ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11736fda06d3d03f03a366339e8c21b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalintc_8c.html#a11736fda06d3d03f03a366339e8c21b8">INTCCommonIntrHandler</a> (void)</td></tr>
<tr class="memdesc:a11736fda06d3d03f03a366339e8c21b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is the common interrupt handler. On any interrupt this handler is called which will resolve and call the corresponding handler. At the end of interrupt handling, the EOI register is updated, so that each interrupt handler need not write to EOI.  <a href="#a11736fda06d3d03f03a366339e8c21b8">More...</a><br /></td></tr>
<tr class="separator:a11736fda06d3d03f03a366339e8c21b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f72c7a3dd3d50b45e37c35c4c2f21d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7f72c7a3dd3d50b45e37c35c4c2f21d"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalintc_8c.html#af7f72c7a3dd3d50b45e37c35c4c2f21d">INTCInit</a> (uint32_t isCpuSecure)</td></tr>
<tr class="memdesc:af7f72c7a3dd3d50b45e37c35c4c2f21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to initialize the interrupt controller. This API shall be called before using the interrupt controller. <br /></td></tr>
<tr class="separator:af7f72c7a3dd3d50b45e37c35c4c2f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa7f943c0b38c42d328ffa11cf8fb1a80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7f943c0b38c42d328ffa11cf8fb1a80"></a>
static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalintc_8c.html#aa7f943c0b38c42d328ffa11cf8fb1a80">pIntrHandlers</a> [AINTC_MAX_INTR_NO])(uint32_t intrId, uint32_t cpuId, void *pUserParam)</td></tr>
<tr class="memdesc:aa7f943c0b38c42d328ffa11cf8fb1a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of function pointers to hold call back functions for Interrupt handlers. This list will be used for calling the call back functions of interrupts. <br /></td></tr>
<tr class="separator:aa7f943c0b38c42d328ffa11cf8fb1a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3112a0209bac1d0cc9a8966739d80482"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3112a0209bac1d0cc9a8966739d80482"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalintc_8c.html#a3112a0209bac1d0cc9a8966739d80482">pUserParameter</a> [AINTC_MAX_INTR_NO]</td></tr>
<tr class="memdesc:a3112a0209bac1d0cc9a8966739d80482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to hold the user parameters passed during interrupt registration. The same will be passed to the corresponding interrupt handlers. <br /></td></tr>
<tr class="separator:a3112a0209bac1d0cc9a8966739d80482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1130507327dfec5b44640e385d6bab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1130507327dfec5b44640e385d6bab"></a>
static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalintc_8c.html#a0d1130507327dfec5b44640e385d6bab">spuriousIntrCnt</a> = 0</td></tr>
<tr class="memdesc:a0d1130507327dfec5b44640e385d6bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter to hold the number of spurious interrupt occurred. <br /></td></tr>
<tr class="separator:a0d1130507327dfec5b44640e385d6bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e91f74ad0537398addde9c14c31ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a5e91f74ad0537398addde9c14c31ad"></a>
static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalintc_8c.html#a8a5e91f74ad0537398addde9c14c31ad">isIntcInitialized</a> = FALSE</td></tr>
<tr class="memdesc:a8a5e91f74ad0537398addde9c14c31ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate if the interrupt controller is already initialized. <br /></td></tr>
<tr class="separator:a8a5e91f74ad0537398addde9c14c31ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interrupt APIs implementation for ARM interrupt controller. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a11736fda06d3d03f03a366339e8c21b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INTCCommonIntrHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is the common interrupt handler. On any interrupt this handler is called which will resolve and call the corresponding handler. At the end of interrupt handling, the EOI register is updated, so that each interrupt handler need not write to EOI. </p>
<p>Note: The below method of calling common handler from IRQ/FIQ vector and then calling the specific interrupt handler involves function calling overhead. Since the processor will be running at higher frequencies the overhead is assumed to be negligible. Instead the specific interrupt handler can be called from IRQ/FIQ vector if the application requires lesser interrupt latency. But this will make the IRQ/FIQ vector tied to specific intr Controller, effectively reducing the portability of IRQ/FIQ vector code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a432332389a8de98ed6abc065a49612ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntDefaultHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Default Interrupt Handler. This is the default interrupt handler for all interrupts. The control would reach here if the interrupt is not configured. So to bring to users attention a message will be printed and wait infinitely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrId</td><td>Interrupt number which is active currently </td></tr>
    <tr><td class="paramname">cpuId</td><td>CPU ID of the processor which generated the SGI (Software Generated Interrupt). This is valid only in multi-proc environment (SMP).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2017, Texas Instruments Incorporated</small>
</body>
</html>
