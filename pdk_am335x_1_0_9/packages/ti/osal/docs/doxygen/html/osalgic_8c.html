<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>osalgic.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ea9599923402ca8ab47fc3e495999dea.html">arch</a></li><li class="navelem"><a class="el" href="dir_8a12bfbc6daf0ca9a5e29c731dcf645d.html">core</a></li><li class="navelem"><a class="el" href="dir_4db544ee109af9a8b12b0a8614cda990.html">a9</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">osalgic.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file implements the GIC related API's.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;types.h&quot;</code><br />
<code>#include &quot;interrupt.h&quot;</code><br />
<code>#include &quot;hw_types.h&quot;</code><br />
<code>#include &quot;gic.h&quot;</code><br />
<code>#include &quot;hw_gic_distributor.h&quot;</code><br />
<code>#include &quot;hw_gic_cpu.h&quot;</code><br />
<code>#include &quot;error.h&quot;</code><br />
<code>#include &quot;cpu.h&quot;</code><br />
<code>#include &quot;console_utils.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1a0d639463595615ef601d9059c042ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a1a0d639463595615ef601d9059c042ac">GIC_DISTR_SET_CLR_MASK</a>(intrNum)&#160;&#160;&#160;(0x1 &lt;&lt; ((intrNum) % 32))</td></tr>
<tr class="separator:a1a0d639463595615ef601d9059c042ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11736fda06d3d03f03a366339e8c21b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a11736fda06d3d03f03a366339e8c21b8">INTCCommonIntrHandler</a> (void)</td></tr>
<tr class="memdesc:a11736fda06d3d03f03a366339e8c21b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is the common interrupt handler. On any interrupt this handler is called which will resolve and call the corresponding handler. At the end of interrupt handling, the EOI register is updated, so that each interrupt handler need not write to EOI.  <a href="#a11736fda06d3d03f03a366339e8c21b8">More...</a><br /></td></tr>
<tr class="separator:a11736fda06d3d03f03a366339e8c21b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432332389a8de98ed6abc065a49612ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a432332389a8de98ed6abc065a49612ad">IntDefaultHandler</a> (uint32_t intrId, uint32_t cpuId, void *pUserParam)</td></tr>
<tr class="memdesc:a432332389a8de98ed6abc065a49612ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Default Interrupt Handler. This is the default interrupt handler for all interrupts. The control would reach here if the interrupt is not configured. So to bring to users attention a message will be printed and wait infinitely.  <a href="#a432332389a8de98ed6abc065a49612ad">More...</a><br /></td></tr>
<tr class="separator:a432332389a8de98ed6abc065a49612ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c98b54c07226d949e33edc0da7467f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a5c98b54c07226d949e33edc0da7467f8">InitGicData</a> (void)</td></tr>
<tr class="memdesc:a5c98b54c07226d949e33edc0da7467f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize GIC data object with information from implementation.  <a href="#a5c98b54c07226d949e33edc0da7467f8">More...</a><br /></td></tr>
<tr class="separator:a5c98b54c07226d949e33edc0da7467f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c473da1759cb41447a7360b4843bc63"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a7c473da1759cb41447a7360b4843bc63">InitGicDist</a> (void)</td></tr>
<tr class="memdesc:a7c473da1759cb41447a7360b4843bc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the GIC Distributor sub-module.  <a href="#a7c473da1759cb41447a7360b4843bc63">More...</a><br /></td></tr>
<tr class="separator:a7c473da1759cb41447a7360b4843bc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a670afc4ec93e541e7b8a74f9daf5b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a02a670afc4ec93e541e7b8a74f9daf5b">InitGicCpu</a> (uint32_t isCpuSecure)</td></tr>
<tr class="memdesc:a02a670afc4ec93e541e7b8a74f9daf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the GIC CPU interface sub-module.  <a href="#a02a670afc4ec93e541e7b8a74f9daf5b">More...</a><br /></td></tr>
<tr class="separator:a02a670afc4ec93e541e7b8a74f9daf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448c5cfb69310b7ef0f9f1e79561a212"><td class="memItemLeft" align="right" valign="top">static intrSupport_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a448c5cfb69310b7ef0f9f1e79561a212">isIntrSupported</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:a448c5cfb69310b7ef0f9f1e79561a212"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API checks if the interrupt is supported. GIC doesn't need to implement the interrupts in continous range. So each interrupt should be checked if it is supported. It also checks if the interrupt is permanently enabled.  <a href="#a448c5cfb69310b7ef0f9f1e79561a212">More...</a><br /></td></tr>
<tr class="separator:a448c5cfb69310b7ef0f9f1e79561a212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f72c7a3dd3d50b45e37c35c4c2f21d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#af7f72c7a3dd3d50b45e37c35c4c2f21d">INTCInit</a> (uint32_t isCpuSecure)</td></tr>
<tr class="memdesc:af7f72c7a3dd3d50b45e37c35c4c2f21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize GIC controller.  <a href="#af7f72c7a3dd3d50b45e37c35c4c2f21d">More...</a><br /></td></tr>
<tr class="separator:af7f72c7a3dd3d50b45e37c35c4c2f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3778a192e3e01e9b1a35b1fbbc63eb46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3778a192e3e01e9b1a35b1fbbc63eb46"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a3778a192e3e01e9b1a35b1fbbc63eb46">INTCClearIntr</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:a3778a192e3e01e9b1a35b1fbbc63eb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of GIC, the normal interrupts need not be cleared, they will be cleared once the interrupts is taken. But for software interrupts, user need to call this API to clear the interrupt. <br /></td></tr>
<tr class="separator:a3778a192e3e01e9b1a35b1fbbc63eb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4d95ca8112519da6b9a4334d7b62e7be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d95ca8112519da6b9a4334d7b62e7be"></a>
static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a4d95ca8112519da6b9a4334d7b62e7be">pIntrHandlers</a> [GIC_MAX_INTR_NO])(uint32_t intrId, uint32_t cpuId, void *pUserParam)</td></tr>
<tr class="memdesc:a4d95ca8112519da6b9a4334d7b62e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of function pointers to hold call back functions for Interrupt handlers. This list will be used for calling the call back functions of interrupts. <br /></td></tr>
<tr class="separator:a4d95ca8112519da6b9a4334d7b62e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb6f62307f4e9de12fcb18c3148e93e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb6f62307f4e9de12fcb18c3148e93e"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a8fb6f62307f4e9de12fcb18c3148e93e">pUserParameter</a> [GIC_MAX_INTR_NO]</td></tr>
<tr class="memdesc:a8fb6f62307f4e9de12fcb18c3148e93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to hold the user parameters passed during interrupt registration. The same will be passed to the corresponding interrupt handlers. <br /></td></tr>
<tr class="separator:a8fb6f62307f4e9de12fcb18c3148e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1130507327dfec5b44640e385d6bab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1130507327dfec5b44640e385d6bab"></a>
static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a0d1130507327dfec5b44640e385d6bab">spuriousIntrCnt</a> = 0</td></tr>
<tr class="memdesc:a0d1130507327dfec5b44640e385d6bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter to hold the number of spurious interrupt occurred. <br /></td></tr>
<tr class="separator:a0d1130507327dfec5b44640e385d6bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c21b7d59a6c3f10c7ef520a47f2fa75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c21b7d59a6c3f10c7ef520a47f2fa75"></a>
static gicData_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a6c21b7d59a6c3f10c7ef520a47f2fa75">gicData</a></td></tr>
<tr class="memdesc:a6c21b7d59a6c3f10c7ef520a47f2fa75"><td class="mdescLeft">&#160;</td><td class="mdescRight">GIC data object. In multiprocessor system this variable should to be placed in shared memory area. <br /></td></tr>
<tr class="separator:a6c21b7d59a6c3f10c7ef520a47f2fa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e91f74ad0537398addde9c14c31ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a5e91f74ad0537398addde9c14c31ad"></a>
static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osalgic_8c.html#a8a5e91f74ad0537398addde9c14c31ad">isIntcInitialized</a> = FALSE</td></tr>
<tr class="memdesc:a8a5e91f74ad0537398addde9c14c31ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate if the interrupt controller is already initialized. <br /></td></tr>
<tr class="separator:a8a5e91f74ad0537398addde9c14c31ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements the GIC related API's. </p>
<p>Architecture of GIC: The GIC has one interrupt distributor which receives the interrupts from external devices and based on the configuration it passes to the CPU interface. The GIC has one CPU interface per CPU. The CPU interface base address is aliased, so that same address can be used to program from different CPU's. The CPU interface takes the interrupts send by distributor and sends the interrupts to CPU. The interrupts are grouped as, </p><pre class="fragment"> 0    - 15   -&gt; Software Generated Interrupts
 16   - 31   -&gt; Private Peripheral Interrupts
 32   - 1019 -&gt; Shared Peripheral Interrupts
 1020 - 1023 -&gt; Reserved
</pre><p>Interrupts 0-31 are private to each CPU and the registers to configure them are banked for each CPU.</p>
<p>GIC is capable of handling secure and non secure interrupts, which can be configured with the API's. It also supports SMP (Symmetric Multi Processing), but the current implementation doesn't support this..</p>
<p>For more info on GIC, please refer GIC architecture Specification.</p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2013-2016 Texas Instruments Incorporated - <a href="http://www.ti.com/">http://www.ti.com/</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a1a0d639463595615ef601d9059c042ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GIC_DISTR_SET_CLR_MASK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">intrNum</td><td>)</td>
          <td>&#160;&#160;&#160;(0x1 &lt;&lt; ((intrNum) % 32))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of Texas Instruments Incorporated nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a02a670afc4ec93e541e7b8a74f9daf5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void InitGicCpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>isCpuSecure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function initializes the GIC CPU interface sub-module. </p>
<ul>
<li>Disable the SGI and PPI interrupts</li>
<li>Configure the priority of PPI and SGI interrupts</li>
<li>Configure the priority mask value to the lowest</li>
<li>Enable CPU interface to signal the interrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a5c98b54c07226d949e33edc0da7467f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void InitGicData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize GIC data object with information from implementation. </p>
<ul>
<li>Max Interrupts supported (DIST_CTR)</li>
<li>Max Interrupts CPU interface supported</li>
<li>Is secure extension supported</li>
<li>Number of Lockable SPI interrupts</li>
<li>Initialize default interrupt handlers for all interrupt ID's</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a7c473da1759cb41447a7360b4843bc63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void InitGicDist </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function initializes the GIC Distributor sub-module. </p>
<ul>
<li>Disable the module</li>
<li>Configure all the SPI interrupts to<ul>
<li>set the priority of all SPI interrupts to lowest</li>
<li>disable all the SPI interrupts</li>
</ul>
</li>
<li>Enable the module</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a11736fda06d3d03f03a366339e8c21b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INTCCommonIntrHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is the common interrupt handler. On any interrupt this handler is called which will resolve and call the corresponding handler. At the end of interrupt handling, the EOI register is updated, so that each interrupt handler need not write to EOI. </p>
<p>Note: The below method of calling common handler from IRQ/FIQ vector and then calling the specific interrupt handler involves function calling overhead. Since the processor will be running at higher frequencies the overhead is assumed to be negligible. Instead the specific interrupt handler can be called from IRQ/FIQ vector if the application requires lesser interrupt latency. But this will make the IRQ/FIQ vector tied to specific intr Controller, effectively reducing the portability of IRQ/FIQ vector code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="af7f72c7a3dd3d50b45e37c35c4c2f21d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t INTCInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>isCpuSecure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize GIC controller. </p>
<ul>
<li>Initialize CPU interface and distributor bases</li>
<li>Initialize distributor and CPU intf sub-modules </li>
</ul>

</div>
</div>
<a class="anchor" id="a432332389a8de98ed6abc065a49612ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntDefaultHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Default Interrupt Handler. This is the default interrupt handler for all interrupts. The control would reach here if the interrupt is not configured. So to bring to users attention a message will be printed and wait infinitely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrId</td><td>Interrupt number which is active currently </td></tr>
    <tr><td class="paramname">cpuId</td><td>CPU ID of the processor which generated the SGI (Software Generated Interrupt). This is valid only in multi-proc environment (SMP).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a448c5cfb69310b7ef0f9f1e79561a212"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static intrSupport_t isIntrSupported </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API checks if the interrupt is supported. GIC doesn't need to implement the interrupts in continous range. So each interrupt should be checked if it is supported. It also checks if the interrupt is permanently enabled. </p>
<p>If the processor implements the Security Extensions, Secure software determines which interrupts are visible to Non-secure software. So in such systems secure init must happen before NS configurations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>intrSupport_t - return if the interrupt is supported </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2017, Texas Instruments Incorporated</small>
</body>
</html>
